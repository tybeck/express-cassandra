{
  "name": "Express Cassandra",
  "tagline": "Framework Independent Cassandra Object Models (ORM) for NodeJS",
  "body": "[![Build Status](https://travis-ci.org/masumsoft/express-cassandra.svg)](https://travis-ci.org/masumsoft/express-cassandra)\r\n[![Download Stats](https://img.shields.io/npm/dm/express-cassandra.svg)](https://www.npmjs.com/package/express-cassandra)\r\n[![Npm Version](https://badge.fury.io/js/express-cassandra.svg)](https://www.npmjs.com/package/express-cassandra)\r\n\r\nexpress-cassandra\r\n===================\r\n\r\nNo more hassling with raw cql queries from your nodejs web frameworks. express-cassandra automatically loads your models and provides you with object oriented mapping to your cassandra tables like a standard ORM.\r\n\r\nThis module uses datastax [cassandra-driver](https://github.com/datastax/nodejs-driver) for node and many of the orm features are wrapper over a largely modified version of [apollo-cassandra](https://github.com/3logic/apollo-cassandra) module. The modifications made to the orm library was necessary to support missing features in the orm, keep it updated with the latest cassandra releases and to make it compatible with requirements of this module.\r\n\r\n\r\n## Installation\r\n\r\nFor cassandra version 3.x\r\n\r\n    npm install express-cassandra\r\n\r\nFor older cassandra 2.x\r\n\r\n    npm install express-cassandra@0.5.4\r\n\r\nPlease note that if you use the legacy cassandra 2.x compliant version then please use the corresponding README.md file for that version. The following documentation is for version 3.x only. The materialized view support and several other part of the documentation is strictly applicable for cassandra 3.x and will not work in earlier versions of cassandra.\r\n\r\n## Usage\r\n\r\n```js\r\nvar models = require('express-cassandra');\r\n\r\n//Tell express-cassandra to use the models-directory, and\r\n//use bind() to load the models using cassandra configurations.\r\n\r\n//If your keyspace doesn't exist it will be created automatically\r\n//using the default replication strategy provided here.\r\n\r\n//If dropTableOnSchemaChange=true, then if your model schema changes,\r\n//the corresponding cassandra table will be dropped and recreated with\r\n//the new schema. Setting this to false will send an error message\r\n//in callback instead for any model attribute changes.\r\n//\r\n//If createKeyspace=false, then it won't be checked whether the\r\n//specified keyspace exists and, if not, it won't get created\r\n// automatically.\r\nmodels.setDirectory( __dirname + '/models').bind(\r\n    {\r\n        clientOptions: {\r\n            contactPoints: ['127.0.0.1'],\r\n            protocolOptions: { port: 9042 },\r\n            keyspace: 'mykeyspace',\r\n            queryOptions: {consistency: models.consistencies.one}\r\n        },\r\n        ormOptions: {\r\n            defaultReplicationStrategy : {\r\n                class: 'SimpleStrategy',\r\n                replication_factor: 1\r\n            },\r\n            dropTableOnSchemaChange: false, //recommended to keep it false in production, use true for development convenience.\r\n            createKeyspace: true\r\n        }\r\n    },\r\n    function(err) {\r\n        if(err) console.log(err.message);\r\n        else console.log(models.timeuuid());\r\n    }\r\n);\r\n\r\n```\r\n\r\nAlternatively if you don't want to load your models automatically from a specific directory and want to define and load models yourself, then you can asynchronously load your schemas like the following:\r\n\r\n```js\r\nvar Cassandra = require('express-cassandra');\r\nvar cassandra = Cassandra.createClient({\r\n    clientOptions: {\r\n        contactPoints: ['127.0.0.1'],\r\n        protocolOptions: { port: 9042 },\r\n        keyspace: 'mykeyspace',\r\n        queryOptions: {consistency: Cassandra.consistencies.one}\r\n    },\r\n    ormOptions: {\r\n        defaultReplicationStrategy : {\r\n            class: 'SimpleStrategy',\r\n            replication_factor: 1\r\n        },\r\n        dropTableOnSchemaChange: false,\r\n        createKeyspace: true\r\n    }\r\n});\r\n\r\n\r\nvar UserSchema = cassandra.loadSchema('users', {\r\n    fields: {\r\n        name: 'text',\r\n        password: 'text'\r\n    },\r\n    key: ['name']\r\n});\r\n\r\ncassandra.connect(function (err) {\r\n    if (err) {\r\n        console.log(err.message);\r\n    } else {\r\n        console.log(cassandra.modelInstance.users);\r\n        console.log(cassandra.modelInstance.users === UserSchema);\r\n    }\r\n});\r\n\r\n```\r\n\r\n## Write a Model named `PersonModel.js` inside models directory\r\n\r\n```js\r\n\r\nmodule.exports = {\r\n    fields:{\r\n        name    : \"text\",\r\n        surname : \"text\",\r\n        age     : \"int\"\r\n    },\r\n    key:[\"name\"]\r\n}\r\n\r\n```\r\n\r\nNote that a model class name should contain the word `Model` in it,\r\notherwise it won't be treated as a model class.\r\n\r\n## Let's insert some data into PersonModel\r\n\r\n```js\r\n\r\nvar john = new models.instance.Person({name: \"John\", surname: \"Doe\", age: 32});\r\njohn.save(function(err){\r\n    if(err) console.log(err);\r\n    else console.log('Yuppiie!');\r\n});\r\n\r\n```\r\n\r\n## Now let's find it\r\n\r\n```js\r\n\r\nmodels.instance.Person.findOne({name: 'John'}, function(err, john){\r\n    if(err) throw err;\r\n\r\n    //Note that returned variable john here is an instance of your model,\r\n    //so you can also do john.delete(), john.save() type operations on the instance.\r\n    console.log('Found ' + john.name + ' to be ' + john.age + ' years old!');\r\n});\r\n\r\n```\r\n\r\n## Model Schema in detail by example\r\n\r\n```js\r\n\r\nmodule.exports = {\r\n    fields: {\r\n        id: {\r\n            type: \"uuid\",\r\n            default: {\"$db_function\": \"uuid()\"}\r\n        },\r\n        name: { type: \"varchar\", default: \"no name provided\"},\r\n        surname: { type: \"varchar\", default: \"no surname provided\"},\r\n        complete_name: {\r\n            type: \"varchar\",\r\n            default: function() {\r\n                return this.name + ' ' + this.surname;\r\n            }\r\n        },\r\n        age: \"int\",\r\n        active: \"boolean\",\r\n        created: {\r\n            type: \"timestamp\",\r\n            default: {\"$db_function\": \"toTimestamp(now())\"}\r\n        }\r\n    },\r\n    key : [[\"id\"],\"created\"],\r\n    clustering_order: {\"created\": \"desc\"},\r\n    materialized_views: {\r\n        view_name1: {\r\n            select: [\"name\",\"age\"],\r\n            key : [\"age\",\"created\",\"id\"],\r\n        },\r\n        view_name2: {\r\n            select: [\"name\",\"age\",\"active\"],\r\n            key : [[\"name\", \"id\"],\"created\"],\r\n            clustering_order: {\"created\": \"desc\"}\r\n        }\r\n    },\r\n    indexes: [\"name\"],\r\n    custom_index: {\r\n        on: 'age',\r\n        using: 'path.to.the.IndexClass',\r\n        options: {\r\n            option1 : '...',\r\n            option2: '...'\r\n        }\r\n    },\r\n    table_name: \"my_custom_table_name\"\r\n}\r\n\r\n```\r\n\r\nWhat does the above code means?\r\n\r\n- `fields` are the columns of your table. For each column name the value can be a string representing the type or an object containing more specific informations. i.e.\r\n    + ` \"id\"     : { \"type\": \"uuid\", \"default\": {\"$db_function\": \"uuid()\"} },` in this example id type is `uuid` and the default value is a cassandra function (so it will be executed from the database).\r\n    + `\"name\"   : { \"type\": \"varchar\", \"default\": \"no name provided\"},` in this case name is a varchar and, if no value will be provided, it will have a default value of `no name provided`. The same goes for `surname`.\r\n    + `complete_name` the default values is calculated from others field. When the orm processes your model instances, the `complete_name` will be the result of the function you defined. In the function `this` is bound to the current model instance.\r\n    + `age` no default is provided and we could write it just as `age: \"int\"`.\r\n    + `active` no default is provided and we could write it just as `active: \"boolean\"`.\r\n    + `created`, like uuid(), will be evaluated from cassandra using the `now()` function.\r\n\r\n- `key`: here is where you define the primary key of your table. As you can imagine, the array defines a `compound primary key` and the first value of the array is the `partition key` and the others are the `clustering keys`. The `partition key` itself can be an array with multiple fields. When a partition key is an array of multiple fields, it is called a `composite` partition key.\r\n\r\nThe partition key is the key field by which cassandra distributes it's data into multiple machines. So when querying cassandra, in most cases you need to provide the partition key, so cassandra knows which machines or partitions contains the data you are looking for.\r\n\r\nThe clustering keys are used to keep the data sorted according to the field values of those keys in a partition. So that after getting into a partition, cassandra can find the required data under those partitions very quickly. As the data is sorted according to those keys, cassandra can efficiently seek to find the data it needs.\r\n\r\nUnderstanding the primary key parts is a crucial concept to cassandra data modeling. To get a detailed idea about them, read the cassandra documentation. For your convenience, following are some links to the relevant documentation pages:\r\n\r\nRead more about composite keys on the [composite key doc](http://docs.datastax.com/en/cql/3.3/cql/cql_using/useCompositePartitionKeyConcept.html)\r\n\r\nRead more about the compound key here on the [compound key documentation](http://docs.datastax.com/en/cql/3.3/cql/cql_using/useCompoundPrimaryKeyConcept.html)\r\n\r\n- `clustering_order`: here you can define the clustering order of the clustering keys. If order is not defined, default value of ASC (ascending) is used.\r\n\r\n- `materialized_views` provides you the ability to define cassandra 3.x materialized views for your model table. You may want to read more about it on the [materialized view documentation](http://docs.datastax.com/en/cql/3.3/cql/cql_using/useCreateMV.html). This is generally suited for querying high cardinality fields. If you need to use select * for the materialized view, you can also use `select: ['*']`.\r\n\r\n- `indexes` are the index of your table. It's always an array of field names. You can read more on the [index documentation](http://docs.datastax.com/en/cql/3.3/cql/cql_using/usePrimaryIndex.html). This is generally suited for querying low cardinality fields, but not as low as boolean fields or fields with very limited number of variants. Very low cardinality fields are not a good separator of large datasets and hence not worthwhile to index.\r\n\r\n- `custom_index` provides the ability to define custom indexes with a Cassandra table. The `on` section should contain the column name on which the index should be built, the `using` section should contain the custom indexer class path and the `options` section should contain the passed options for the indexer class if any.\r\n\r\n- `table_name` provides the ability to use a different name for the actual table in cassandra. By default the lowercased modelname is used as the table name. But if you want a different table name instead, then you may want to use this optional field to specify the custom name for your cassandra table.\r\n\r\nWhen you instantiate a model, every field you defined in schema is automatically a property of your instances. So, you can write:\r\n\r\n```js\r\n\r\njohn.age = 25;\r\nconsole.log(john.name); //John\r\nconsole.log(john.complete_name); // undefined.\r\n\r\n```\r\n__note__: `john.complete_name` is undefined in the newly created instance but will be populated when the instance is saved because it has a default value in schema definition\r\n\r\nOk, we are done with John, let's delete it:\r\n\r\n```js\r\n\r\njohn.delete(function(err){\r\n    //...\r\n});\r\n\r\n```\r\n\r\n### A few handy tools for your model\r\n\r\nExpress cassandra exposes some node driver methods for convenience. To generate uuids e.g. in field defaults:\r\n\r\n*   `models.uuid()`\r\n    returns a type 3 (random) uuid, suitable for Cassandra `uuid` fields, as a string\r\n*   `models.uuidFromString(str)`\r\n    returns a type 3 uuid from input string, suitable for Cassandra `uuid` fields\r\n*   `models.timeuuid() / .maxTimeuuid() / .minTimeuuid()`\r\n    returns a type 1 (time-based) uuid, suitable for Cassandra `timeuuid` fields, as a string. From the [Datastax documentation](https://docs.datastax.com/en/cql/3.3/cql/cql_reference/timeuuid_functions_r.html):\r\n\r\n    > The min/maxTimeuuid example selects all rows where the timeuuid column, t, is strictly later than 2013-01-01 00:05+0000 but strictly earlier than 2013-02-02 10:00+0000. The t >= maxTimeuuid('2013-01-01 00:05+0000') does not select a timeuuid generated exactly at 2013-01-01 00:05+0000 and is essentially equivalent to t > maxTimeuuid('2013-01-01 00:05+0000').\r\n\r\n    > The values returned by minTimeuuid and maxTimeuuid functions are not true UUIDs in that the values do not conform to the Time-Based UUID generation process specified by the RFC 4122. The results of these functions are deterministic, unlike the now function.\r\n*   `models.consistencies`\r\n    this object contains all the available consistency enums defined by node cassandra driver, so you can for example use models.consistencies.one, models.consistencies.quorum etc.\r\n*   `models.datatypes`\r\n    this object contains all the available datatypes defined by node cassandra driver, so you can for example use\r\n    models.datatypes.Long to deal with the cassandra bigint or counter field types.\r\n\r\n\r\n### Cassandra to Javascript Datatypes\r\n\r\nWhen saving or retrieving the value of a column, the value is typed according to the following table.\r\n\r\n| Cassandra Field Types  |  Javascript Types                 |\r\n|------------------------|-----------------------------------|\r\n|     ascii              |     String                        |\r\n|     bigint             |     [models.datatypes.Long](https://google.github.io/closure-library/api/class_goog_math_Long.html)|\r\n|     blob               |     [Buffer](https://nodejs.org/api/buffer.html)|\r\n|     boolean            |     Boolean                       |\r\n|     counter            |     [models.datatypes.Long](https://google.github.io/closure-library/api/class_goog_math_Long.html)|\r\n|     date               |     [models.datatypes.LocalDate](http://docs.datastax.com/en/drivers/nodejs/3.0/module-types-LocalDate.html)|\r\n|     decimal            |     [models.datatypes.BigDecimal](http://docs.datastax.com/en/drivers/nodejs/3.0/module-types-BigDecimal.html)|\r\n|     double             |     Number                        |\r\n|     float              |     Number                        |\r\n|     inet               |     [models.datatypes.InetAddress](http://docs.datastax.com/en/drivers/nodejs/3.0/module-types-InetAddress.html)|\r\n|     int                |     Number (Integer)              |\r\n|     list               |     Array                         |\r\n|     map                |     Object                        |\r\n|     set                |     Array                         |\r\n|     smallint           |     Number (Integer)|\r\n|     text               |     String                        |\r\n|     time               |     [models.datatypes.LocalTime](http://docs.datastax.com/en/drivers/nodejs/3.0/module-types-LocalTime.html)|\r\n|     timestamp          |     Date                          |\r\n|     timeuuid           |     [models.datatypes.TimeUuid](http://docs.datastax.com/en/drivers/nodejs/3.0/module-types-TimeUuid.html)|\r\n|     tinyint            |     Number (Integer)|\r\n|     tuple              |     [models.datatypes.Tuple](http://docs.datastax.com/en/drivers/nodejs/3.0/module-types-Tuple.html)|\r\n|     uuid               |     [models.datatypes.Uuid](http://docs.datastax.com/en/drivers/nodejs/3.0/module-types-Uuid.html)|\r\n|     varchar            |     String                        |\r\n|     varint             |     [models.datatypes.Integer](http://docs.datastax.com/en/drivers/nodejs/3.0/module-types-Integer.html)|\r\n\r\n\r\nFor example, you have a User model schema like the following:\r\n\r\n```js\r\nmodule.exports = {\r\n    \"fields\": {\r\n        \"user_id\": \"bigint\",\r\n        \"user_name\": \"text\"\r\n    },\r\n    \"key\" : [\"user_id\"]\r\n}\r\n```\r\n\r\nNow to insert data in the model, you need the Long data type. To create a Long type data, you can use the `models.datatypes.Long` like the following:\r\n\r\n```js\r\nvar user = new models.instance.User({\r\n    user_id: models.datatypes.Long.fromString('1234556567676782'),\r\n    user_name: 'john'\r\n});\r\nuser.save(function(err){\r\n    //Now let's find the saved user\r\n    models.instance.User.findOne({user_id: models.datatypes.Long.fromString('1234556567676782')}, function(err, john){\r\n        console.log(john.user_id.toString()); // john.user_id is of type Long.\r\n    });\r\n});\r\n```\r\n\r\n### Null and unset values\r\n\r\nTo complete a distributed DELETE operation, Cassandra replaces it with a special value called a tombstone which can be propagated to replicas. When inserting or updating a field, you can set a certain field to null as a way to clear the value of a field, and it is considered a DELETE operation. In some cases, you might insert rows using null for values that are not specified, and even though our intention is to leave the value empty, Cassandra represents it as a tombstone causing unnecessary overhead.\r\n\r\nTo avoid tombstones, cassandra has the concept of unset for a parameter value. So you can do the following to unset a field value for example:\r\n\r\n```js\r\nmodels.instance.User.update({user_id: models.datatypes.Long.fromString('1234556567676782')}, {\r\n    user_name: models.datatypes.unset\r\n}, function(err){\r\n    //user name is now unset\r\n})\r\n```\r\n\r\n### Counter Column Operations\r\n\r\nCassandra counter column increment and decrement operations are supported via the update operation. To increment/decrement a counter, you can use the following types of update operation:\r\n\r\n```js\r\n//Say your model name is StatsModel that has a user_id as the primary key and visit_count as a counter column.\r\n\r\nmodels.instance.Stats.update({user_id:1234}, {visit_count:2}, function(err){\r\n    //visit_count will be incremented by 2\r\n});\r\n\r\nmodels.instance.Stats.update({user_id:1234}, {visit_count:-1}, function(err){\r\n    //visit_count will be decremented by 1\r\n});\r\n```\r\n\r\nPlease note that counter columns has special limitations, to know more about the counter column usage, see the [cassandra counter docs](https://docs.datastax.com/en/cql/3.3/cql/cql_using/useCountersConcept.html).\r\n\r\n### Support for Collection Data Types\r\n\r\nCassandra collection data types (`map`, `list` & `set`) are supported in model schema definitions. An additional `typeDef` attribute is used to define the collection type.\r\n\r\n```js\r\n\r\nmodule.exports = {\r\n\r\n    \"fields\": {\r\n\r\n        mymap: {\r\n            type: \"map\",\r\n            typeDef: \"<varchar, text>\"\r\n        },\r\n        mylist: {\r\n            type: \"list\",\r\n            typeDef: \"<varchar>\"\r\n        },\r\n        myset: {\r\n            type: \"set\",\r\n            typeDef: \"<varchar>\"\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\nWhen saving or updating collection types, use an object for a `map` value and use an array for `set` or `list` value like the following:\r\n\r\n```js\r\n\r\nvar person = new models.instance.Person({\r\n\r\n    mymap: {'key1':'val1','key2': 'val2'},\r\n    mylist: ['value1', 'value2'],\r\n    myset: ['value1', 'value2']\r\n\r\n});\r\n\r\nperson.save(function(err){\r\n\r\n});\r\n\r\n```\r\n\r\nIf you want to add/remove/update existing map, list or set, then you can always find it using the find function,\r\nthen change the map, list or set elements in javascript and use the `save` function on that model instance to save the changes.\r\n\r\n```js\r\nmodels.instance.Person.findOne(query, function(err, person){\r\n    person.mymap.key1 = 'val1 new';\r\n    delete person.mymap.key2;\r\n    person.mymap.key3 = 'val3';\r\n    person.mylist.push('value3');\r\n    person.myset.splice(0,1);\r\n\r\n    person.save(function(err){\r\n\r\n    });\r\n});\r\n```\r\n\r\nBut sometimes you may want to add/remove elements into an existing map, list or set in a single call atomically.\r\nSo you can use the update function along with the `$add` and `$remove` directive to do that.\r\n\r\n```js\r\nmodels.instance.Person.update({userID:1234, age:32}, {\r\n    info:{'$add':{'new2':'addition2'}},\r\n    phones:{'$add': ['12345']},\r\n    emails: {'$add': ['e@f.com']}\r\n}, function(err){\r\n    if(err) throw err;\r\n    done();\r\n});\r\n```\r\n\r\n```js\r\nmodels.instance.Person.update({userID:1234, age:32}, {\r\n    info:{'$remove':{'new2':''}},\r\n    phones:{'$remove': ['12345']},\r\n    emails: {'$remove': ['e@f.com']}\r\n}, function(err){\r\n    if(err) throw err;\r\n    done();\r\n});\r\n```\r\n\r\nInstead of `$add`, you may also use `$append`. Both of them will have the same effect. If you want to prepend in a list instead of append, you can use the `$prepend` directive like the following:\r\n\r\n```js\r\nmodels.instance.Person.update({userID:1234, age:32}, {\r\n    phones:{'$prepend': ['654532']}\r\n}, function(err){\r\n\r\n});\r\n```\r\n\r\nYou can also replace a specific item in a map using the `$replace` directive like the following:\r\n\r\n```js\r\nmodels.instance.Person.update({userID:1234, age:32}, {\r\n    info:{'$replace':{'new':'replaced value'}}\r\n}, function(err){\r\n\r\n});\r\n```\r\n\r\nYou may also replace a list item using the index. In this case provide a 2 item array where the first item is the index to replace and the second item is the value you want to set for that index.\r\n\r\n```js\r\nmodels.instance.Person.update({userID:1234, age:32}, {\r\n    phones:{'$replace': [1,'23456']} //replace the phone number at index 1 with the value 23456\r\n}, function(err){\r\n\r\n});\r\n```\r\n\r\n### Support for Frozen Collections\r\n\r\nFrozen collections are useful if you want to use them in the primary key. Frozen collection can only be replaced as a whole, you cannot for example add/remove elements in a frozen collection.\r\n\r\n```js\r\nmyfrozenmap: {\r\n    type: \"frozen\",\r\n    typeDef: \"<map<varchar, text>>\"\r\n}\r\n```\r\n\r\n### Support for Tuple Data Type\r\n\r\nCassandra tuple data types can be declared using the `frozen` type like the following:\r\n\r\n```js\r\nmytuple: {\r\n    type: \"frozen\",\r\n    typeDef: \"<tuple<int, text, float>>\"\r\n}\r\n```\r\n\r\nTo insert/update data into a tuple, use the cassandra Tuple datatype like the following:\r\n\r\n```js\r\nvar person = new models.instance.Person({\r\n    //...other fields ommitted for clarity\r\n    mytuple: new models.datatypes.Tuple(3, 'bar', 2.1)\r\n});\r\n\r\n```\r\n\r\n### Support for User Defined Types, Functions and Aggregates\r\n\r\nUser defined types (UDTs), user defined functions (UDFs) and user defined aggregates (UDAs) are supported too. The UDTs, UDFs & UDAs should be defined globally against your keyspace. You can defined them in the configuration object passed to initialize express-cassandra, so that express cassandra could create and sync them against your keyspace. So you may be able to use them in your schema definition and queries. The configuration object should have some more object keys representing the user defined types, functions and aggregates under `ormOptions` like the following:\r\n\r\n```js\r\nclientOptions: {\r\n    //... client options are ommitted for clarity\r\n},\r\normOptions: {\r\n    //... other orm options are ommitted for clarity\r\n    udts: {\r\n        phone: {\r\n            alias: 'text',\r\n            phone_number: 'text',\r\n            country_code: 'int'\r\n        },\r\n        address: {\r\n            street: 'text',\r\n            city: 'text',\r\n            state: 'text',\r\n            zip: 'int',\r\n            phones: 'set<frozen<phone>>'\r\n        }\r\n    },\r\n    udfs: {\r\n        fLog: {\r\n            language: 'java',\r\n            code: 'return Double.valueOf(Math.log(input.doubleValue()));',\r\n            returnType: 'double',\r\n            inputs: {\r\n                input: 'double'\r\n            }\r\n        },\r\n        avgState: {\r\n            language: 'java',\r\n            code: 'if (val !=null) { state.setInt(0, state.getInt(0)+1); state.setLong(1,state.getLong(1)+val.intValue()); } return state;',\r\n            returnType: 'tuple<int,bigint>',\r\n            inputs: {\r\n                state: 'tuple<int,bigint>',\r\n                val: 'int'\r\n            }\r\n        },\r\n        avgFinal: {\r\n            language: 'java',\r\n            code: 'double r = 0; if (state.getInt(0) == 0) return null; r = state.getLong(1); r/= state.getInt(0); return Double.valueOf(r);',\r\n            returnType: 'double',\r\n            inputs: {\r\n                state: 'tuple<int,bigint>'\r\n            }\r\n        }\r\n    },\r\n    udas: {\r\n        average: {\r\n            input_types: ['int'],\r\n            sfunc: 'avgState',\r\n            stype: 'tuple<int,bigint>',\r\n            finalfunc: 'avgFinal',\r\n            initcond: '(0,0)'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAfter configuring them for your keyspace, you could possibly define fields using udts like the following:\r\n\r\n```js\r\ncurrencies: {\r\n    type: 'frozen',\r\n    typeDef: '<address>'\r\n}\r\n```\r\n\r\nand use the UDFs and UDAs like any other standard functions using the `select` attribute:\r\n\r\n```js\r\nmodels.instance.Person.findOne({...}, {select: ['fLog(points)','average(age)']}, function(err, user){\r\n    //...\r\n});\r\n```\r\n\r\n### Support for shared static columns\r\n\r\nIn a table that uses clustering columns, non-clustering columns can be declared static in the schema definition like the following:\r\n\r\n```js\r\n\"my_shared_data\": {\r\n    \"type\": \"text\",\r\n    \"static\": true\r\n}\r\n```\r\n\r\nNote that static columns are only static within a given partition. Static columns also has several restrictions described in the cassandra [static column documentation](https://docs.datastax.com/en/cql/3.3/cql/cql_reference/refStaticCol.html).\r\n\r\n### Support for indexed collections\r\n\r\nCollections can be indexed and queried to find a collection containing a particular value. Sets and lists are indexed slightly differently from maps, given the key-value nature of maps.\r\n\r\nSets and lists can index all values found by indexing the collection column. Maps can index a map key, map value, or map entry using the methods shown below. Multiple indexes can be created on the same map column in a table, so that map keys, values, or entries can be queried. In addition, frozen collections can be indexed using FULL to index the full content of a frozen collection.\r\n\r\nFor defining indexed collections or frozen full indexes, you can define the corresponsing fields in your schema definition indexes like the following:\r\n\r\n```js\r\n\"fields\": {...},\r\n\"key\": [...],\r\n\"indexes\": [\"my_list\",\"my_set\",\"keys(my_map)\",\"entries(my_map)\",\"values(my_map)\",\"full(my_frozen_field)\"],\r\n```\r\n\r\nNow after defining your indexes in your collections, you can use the `$contains` and `$contains_key` directives to query those indexes:\r\n\r\n```js\r\n//Find all persons where my_list contains my_value\r\nmodels.instance.Person.find({my_list: {$contains: 'my_value'}}, {raw: true}, function(err, people){\r\n\r\n});\r\n//Find all persons where my_set contains my_value\r\nmodels.instance.Person.find({my_set: {$contains: 'my_value'}}, {raw: true}, function(err, people){\r\n\r\n});\r\n//Find all persons where my_map keys contains my_key\r\nmodels.instance.Person.find({my_map: {$contains_key: 'my_key'}}, {raw: true}, function(err, people){\r\n\r\n});\r\n//Find all persons where my_map contains object {my_key: 'my_value'}\r\nmodels.instance.Person.find({my_map: {$contains: {my_key: 'my_value'}}}, {raw: true}, function(err, people){\r\n\r\n});\r\n//Find all persons where my_map contains my_value\r\nmodels.instance.Person.find({my_map: {$contains: 'my_value'}}, {raw: true}, function(err, people){\r\n\r\n});\r\n```\r\n\r\nNow for finding using indexed frozen field using `full` type index, you can directly use the value of the complex object in your query.\r\n\r\nFor example your person schema has a frozen map `myFrozenMap` with typeDef `<map <int, text>>` that is indexed using the `full` keyword like the following:\r\n\r\n```js\r\nfields: {\r\n    myFrozenMap: {\r\n        type: 'frozen',\r\n        typeDef: '<map <text, text>>'\r\n    }\r\n},\r\nkeys: [...],\r\nindexes: ['full(myFrozenMap)']\r\n```\r\n\r\nSo now you may query like the following:\r\n\r\n```js\r\nmodels.instance.Person.find({\r\n    myFrozenMap: {\r\n        my_key: 'my_value'\r\n    }\r\n}, {raw: true}, function(err, people){\r\n    //people is a list of persons where myFrozenMap value is {mykey: 'my_value'}\r\n});\r\n```\r\n\r\n## Virtual fields\r\n\r\nYour model could have some fields which are not saved on database. You can define them as `virtual`\r\n\r\n```js\r\n\r\nmodule.exports = {\r\n    \"fields\": {\r\n        \"id\"     : { \"type\": \"uuid\", \"default\": {\"$db_function\": \"uuid()\"} },\r\n        \"name\"   : { \"type\": \"varchar\", \"default\": \"no name provided\"},\r\n        \"surname\"   : { \"type\": \"varchar\", \"default\": \"no surname provided\"},\r\n        \"complete_name\" : {\r\n            \"type\": \"varchar\",\r\n            \"virtual\" : {\r\n                get: function(){return this.name + ' ' +this.surname;},\r\n                set: function(value){\r\n                    value = value.split(' ');\r\n                    this.name = value[0];\r\n                    this.surname = value[1];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nA virtual field is simply defined adding a `virtual` key in field description. Virtuals can have a `get` and a `set` function, both optional (you should define at least one of them!).\r\n`this` inside get and set functions is bound to current instance of your model.\r\n\r\n## Validators\r\n\r\nEvery time you set a property for an instance of your model, an internal type validator checks that the value is valid. If not an error is thrown. But how to add a custom validator? You need to provide your custom validator in the schema definition. For example, if you want to check age to be a number greater than zero:\r\n\r\n```js\r\n\r\nmodule.exports = {\r\n    //... other properties hidden for clarity\r\n    age: {\r\n        type : \"int\",\r\n        rule : function(value){ return value > 0; }\r\n    }\r\n}\r\n\r\n```\r\n\r\nyour validator must return a boolean. If someone will try to assign `john.age = -15;` an error will be thrown.\r\nYou can also provide a message for validation error in this way\r\n\r\n```js\r\n\r\nmodule.exports = {\r\n    //... other properties hidden for clarity\r\n    age: {\r\n        type : \"int\",\r\n        rule : {\r\n            validator : function(value){ return value > 0; },\r\n            message   : 'Age must be greater than 0'\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nthen the error will have your message. Message can also be a function; in that case it must return a string:\r\n\r\n```js\r\n\r\nmodule.exports = {\r\n    //... other properties hidden for clarity\r\n    age: {\r\n        type : \"int\",\r\n        rule : {\r\n            validator : function(value){ return value > 0; },\r\n            message   : function(value){ return 'Age must be greater than 0. You provided '+ value; }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nThe error message will be `Age must be greater than 0. You provided -15`\r\n\r\nNote that default values _are_ validated if defined either by value or as a javascript function. Defaults defined as DB functions, on the other hand, are never validated in the model as they are retrieved _after_ the corresponding data has entered the DB.\r\nIf you need to exclude defaults from being checked you can pass an extra flag:\r\n\r\n```js\r\n\r\nmodule.exports = {\r\n    //... other properties hidden for clarity\r\n    email: {\r\n        type : \"text\",\r\n        default : \"<enter your email here>\",\r\n        rule : {\r\n            validator : function(value){ /* code to check that value matches an email pattern*/ },\r\n            ignore_default: true\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n## Querying your data\r\n\r\nOk, now you have a bunch of people on db. How do I retrieve them?\r\n\r\n### Find (results are model instances)\r\n\r\n```js\r\n\r\nmodels.instance.Person.find({name: 'John'}, function(err, people){\r\n    if(err) throw err;\r\n    //people is an array of model instances containing the persons with name `John`\r\n    console.log('Found ', people);\r\n});\r\n\r\n//If you specifically expect only a single object after find, you may do this\r\nmodels.instance.Person.findOne({name: 'John'}, function(err, john){\r\n    if(err) throw err;\r\n    //The variable `john` is a model instance containing the person named `John`\r\n    //`john` will be undefined if no person named `John` was found\r\n    console.log('Found ', john.name);\r\n});\r\n\r\n```\r\n\r\nIn the above example it will perform the query `SELECT * FROM person WHERE name='john'` but `find()` allows you to perform even more complex queries on cassandra.  You should be aware of how to query cassandra. Every error will be reported to you in the `err` argument, while in `people` you'll find instances of `Person`.\r\n\r\n#### Find (results are raw objects)\r\n\r\nIf you don't want the orm to cast results to instances of your model you can use the `raw` option as in the following example:\r\n\r\n```js\r\n\r\nmodels.instance.Person.find({name: 'John'}, { raw: true }, function(err, people){\r\n    //people is an array of plain objects\r\n});\r\n\r\n```\r\n\r\n#### Find (A more complex query)\r\n\r\n```js\r\n\r\nvar query = {\r\n    name: 'John', // stays for name='john'\r\n    age : { '$gt':10, '$lte':20 }, // stays for age>10 and age<=20 You can also use $gt, $gte, $lt, $lte, $eq\r\n    surname : { '$in': ['Doe','Smith'] }, //This is an IN clause\r\n    $orderby:{'$asc' :'age'}, //Order results by age in ascending order. Also allowed $desc and complex order like $orderby:{'$asc' : ['k1','k2'] }\r\n    $limit: 10 //limit result set\r\n}\r\n\r\nmodels.instance.Person.find(query, {raw: true}, function(err, people){\r\n    //people is an array of plain objects satisfying the query conditions above\r\n});\r\n\r\n```\r\n\r\n#### Find (results to contain only selected columns)\r\n\r\nYou can also select particular columns using the select key in the options object like the following example:\r\n\r\n```js\r\n\r\nmodels.instance.Person.find({name: 'John'}, { select: ['name as username','age'] }, function(err, people){\r\n    //people is an array of plain objects with only name and age\r\n});\r\n\r\n```\r\n\r\nNote that if you use the `select` option, then the results will always be raw plain objects instead of model instances.\r\n\r\nAlso **Remember** that your select needs to include all the partition key columns defined for your table!\r\n\r\nIf your model key looks like this:\r\n\r\n```js\r\n\r\nmodule.exports = {\r\n    fields: {\r\n        //fields are not shown for clarity\r\n    },\r\n    key : [[\"columnOne\",\"columnTwo\",\"columnThree\"],\"columnFour\",\"ColumnFive\"]\r\n}\r\n\r\n```\r\n\r\nThen your `select`-array has to at least include the partition key columns like this: `select: ['columnOne', 'columnTwo', 'columnThree']`.\r\n\r\n#### Find (using aggregate function)\r\n\r\nYou can also use `aggregate functions` using the select key in the options object like the following example:\r\n\r\n```js\r\n\r\nmodels.instance.Person.find({name: 'John'}, { select: ['name','sum(age)'] }, function(err, people){\r\n    //people is an array of plain objects with sum of all ages where name is John\r\n});\r\n\r\n```\r\n\r\n#### Find (using distinct select)\r\n\r\nAlso, `DISTINCT` selects are possible:\r\n\r\n```js\r\n\r\nmodels.instance.Person.find({}, { select: ['name','age'], distinct: true }, function(err, people){\r\n    //people is a distinct array of plain objects with only distinct name and ages.\r\n});\r\n\r\n```\r\n\r\n#### Find (querying a materialized view)\r\n\r\nAnd if you have defined `materialized views` in your schema as described in the schema detail section, then you can query your views by using the similar find/findOne functions. Just add an option with the materialized view name like the following:\r\n\r\n\r\n```js\r\n\r\nmodels.instance.Person.find({name: 'John'}, { materialized_view: 'view_name1', raw: true }, function(err, people){\r\n    //people is an array of plain objects taken from the materialized view\r\n});\r\n\r\n```\r\n\r\n#### Find (with allow filtering)\r\n\r\nIf you want to set allow filtering option, you may do that like this:\r\n\r\n```js\r\n\r\nmodels.instance.Person.find(query, {raw:true, allow_filtering: true}, function(err, people){\r\n    //people is an array of plain objects\r\n});\r\n\r\n```\r\n\r\n#### Find (using index expression)\r\n\r\nIf you want to use custom index expressions, you may do that like this:\r\n\r\n```js\r\nvar query = {\r\n    $expr: {\r\n        index: 'YOUR_INDEX_NAME',\r\n        query: 'YOUR_CUSTOM_EXPR_QUERY'\r\n    }\r\n}\r\n\r\nmodels.instance.Person.find(query, function(err, people){\r\n\r\n});\r\n\r\n```\r\n\r\n#### Find (fetching large result sets using streaming queries)\r\n\r\nThe stream() method automatically fetches the following pages, yielding the rows as they come through the network and retrieving the following page after the previous rows were read (throttling).\r\n\r\n```js\r\nmodels.instance.Person.stream({Name: 'John'}, {raw: true}, function(reader){\r\n    var row;\r\n    while (row = reader.readRow()) {\r\n        //process row\r\n    }\r\n}, function(err){\r\n    //emitted when all rows have been retrieved and read\r\n});\r\n```\r\n\r\nWith the eachRow() method, you can retrieve the following pages automatically by setting the autoPage flag to true in the query options to request the following pages automatically. Because eachRow() does not handle backpressure, it is only suitable when there is minimum computation per row required and no additional I/O, otherwise it ends up buffering an unbounded amount of rows.\r\n\r\n```js\r\nmodels.instance.Person.eachRow({Name: 'John'}, {autoPage : true}, function(n, row){\r\n    // invoked per each row in all the pages\r\n}, function(err, result){\r\n    // ...\r\n});\r\n```\r\n\r\nIf you want to retrieve the next page of results only when you ask for it (for example, in a web page or after a certain computation or job finished), you can use the eachRow() method in the following way:\r\n\r\n```js\r\nmodels.instance.Person.eachRow({Name: 'John'}, {fetchSize : 100}, function(n, row){\r\n    // invoked per each row in all the pages\r\n}, function(err, result){\r\n    // called once the page has been retrieved.\r\n    if(err) throw err;\r\n    if (result.nextPage) {\r\n        // retrieve the following pages\r\n        // the same row handler from above will be used\r\n        result.nextPage();\r\n    }\r\n});\r\n```\r\n\r\nYou can also use the `pageState` property, a string token made available in the result if there are additional result pages.\r\n\r\n```js\r\nmodels.instance.Person.eachRow({Name: 'John'}, {fetchSize : 100}, function(n, row){\r\n    // invoked per each row in all the pages\r\n}, function(err, result){\r\n    // called once the page has been retrieved.\r\n    if(err) throw err;\r\n    // store the paging state\r\n    pageState = result.pageState;\r\n});\r\n```\r\n\r\nIn the next request, use the page state to fetch the following rows.\r\n\r\n```js\r\nmodels.instance.Person.eachRow({Name: 'John'}, {fetchSize : 100, pageState : pageState}, function(n, row){\r\n    // invoked per each row in all the pages\r\n}, function(err, result){\r\n    // called once the page has been retrieved.\r\n    if(err) throw err;\r\n    // store the next paging state.\r\n      pageState = result.pageState;\r\n});\r\n```\r\n\r\nSaving the paging state works well when you only let the user move from one page to the next. But it doesnâ€™t allow random jumps (like \"go directly to page 10\"), because you can't fetch a page unless you have the paging state of the previous one. Such a feature would require offset queries, which are not natively supported by Cassandra.\r\n\r\nNote: The page state token can be manipulated to retrieve other results within the same column family, so it is not safe to expose it to the users.\r\n\r\n#### Find (token based pagination)\r\n\r\nYou can also use the `token` comparison function while querying a result set using the $token operator. This is specially useful for [paging through unordered partitioner results](https://docs.datastax.com/en/cql/3.3/cql/cql_using/usePaging.html).\r\n\r\n```js\r\n//consider the following situation\r\nvar query = {\r\n    $limit:10\r\n};\r\nmodels.instance.Person.find(query, function(err, people){\r\n    //people is an array of first 10 persons\r\n\r\n    //Say your PRIMARY_KEY column is `name` and the 10th person has the name 'John'\r\n    //Now to get the next 10 results, you may use the $token operator like the following:\r\n    var query = {\r\n        name:{\r\n            '$token':{'$gt':'John'}\r\n        },\r\n        $limit:10\r\n    };\r\n    //The above query translates to `Select * from person where token(name) > token('John') limit 10`\r\n    models.instance.Person.find(query, function(err, people){\r\n        //people is an array of objects containing the 11th - 20th person\r\n    });\r\n});\r\n```\r\n\r\nIf you have a `composite partition key`, then the token operator should be contained in comma (,) separated partition key field names and the values should be an array containing the values for the partition key fields. Following is an example to demonstrate that:\r\n\r\n```js\r\nvar query = {\r\n    'id,name':{\r\n        '$token':{\r\n            '$gt':[1234,'John']\r\n        }\r\n    }\r\n};\r\nmodels.instance.Person.find(query, function(err, people){\r\n\r\n});\r\n```\r\n\r\nNote that all query clauses must be Cassandra compliant. You cannot, for example, use $in operator for a key which is not part of the primary key. Querying in Cassandra is very basic but could be confusing at first. Take a look at this [post](http://mechanics.flite.com/blog/2013/11/05/breaking-down-the-cql-where-clause/) and, obvsiouly, at the [cql query documentation](https://docs.datastax.com/en/cql/3.3/cql/cql_using/useQueryDataTOC.html)\r\n\r\n\r\n## Save / Update / Delete\r\n\r\n### Save\r\n\r\nThe save operation on a model instance will insert a new record with the attribute values mentioned when creating the model object. It will update the record if it already exists in the database. A record is updated or inserted based on the primary key definition. If the primary key values are same as an existing record, then the record will be updated and otherwise it will be inserted as new record.\r\n\r\n```js\r\n\r\nvar john = new models.instance.Person({name: 'John', surname: 'Doe', age: 32});\r\njohn.save(function(err){\r\n    if(err) console.log(err);\r\n    else console.log('Yuppiie!');\r\n});\r\n\r\n```\r\n\r\nYou can use the find query to get an object and modify it and save it like the following:\r\n\r\n```js\r\n\r\nmodels.instance.Person.findOne({name: 'John'}, function(err, john){\r\n    if(err) throw err;\r\n    if(john){\r\n        john.age = 30;\r\n        john.save(function(err){\r\n            if(err) console.log(err);\r\n            else console.log('Yuppiie!');\r\n        });\r\n    }\r\n});\r\n\r\n```\r\n\r\nThe save function also takes optional parameters. By default cassandra will update the row if the primary key\r\nalready exists. If you want to avoid on duplicate key updates, you may set if_not_exist:true.\r\n\r\n```js\r\n\r\njohn.save({if_not_exist: true}, function(err){\r\n    if(err) console.log(err);\r\n    else console.log('Yuppiie!');\r\n});\r\n\r\n```\r\n\r\nYou can also set an expiry ttl for the saved row if you want. In that case the row will be removed by cassandra\r\nautomatically after the time to live has expired.\r\n\r\n```js\r\n\r\n//The row will be removed after 86400 seconds or one day\r\njohn.save({ttl: 86400}, function(err){\r\n    if(err) console.log(err);\r\n    else console.log('Yuppiie!');\r\n});\r\n\r\n```\r\n\r\n### Update\r\n\r\nUse the update function if your requirements are not satisfied with the `save()` function or you directly want to update records without reading them from the db. The update function takes the following forms, (options are optional):\r\n\r\n```js\r\n\r\n/*\r\nUPDATE person\r\n    USING TTL 86400\r\n    SET email='abc@gmail.com'\r\nWHERE username= 'abc'\r\n    IF EXISTS\r\n*/\r\n\r\nvar query_object = {username: 'abc'};\r\nvar update_values_object = {email: 'abc@gmail.com'};\r\nvar options = {ttl: 86400, if_exists: true};\r\nmodels.instance.Person.update(query_object, update_values_object, options, function(err){\r\n    if(err) console.log(err);\r\n    else console.log('Yuppiie!');\r\n});\r\n\r\n\r\n/*\r\nUPDATE person\r\n    SET email='abc@gmail.com'\r\nWHERE username= 'abc'\r\n    IF email='typo@gmail.com'\r\n*/\r\nvar query_object = {username: 'abc'};\r\nvar update_values_object = {email: 'abc@gmail.com'};\r\nvar options = {conditions: {email: 'typo@gmail.com'}};\r\nmodels.instance.Person.update(query_object, update_values_object, options, function(err){\r\n    if(err) console.log(err);\r\n    else console.log('Yuppiie!');\r\n});\r\n\r\n```\r\n\r\n### Delete\r\n\r\nThe delete function takes the following form:\r\n\r\n```js\r\n\r\n//DELETE FROM person WHERE username='abc';\r\nvar query_object = {username: 'abc'};\r\nmodels.instance.Person.delete(query_object, function(err){\r\n    if(err) console.log(err);\r\n    else console.log('Yuppiie!');\r\n});\r\n\r\n```\r\n\r\nIf you have a model instance and you want to delete the instance object, you may do that like the following:\r\n\r\n```js\r\nmodels.instance.Person.findOne({name: 'John'}, function(err, john){\r\n    if(err) throw err;\r\n\r\n    //Note that returned variable john here is an instance of your model,\r\n    //so you can do john.delete() like the following\r\n    john.delete(function(err){\r\n        //...\r\n    });\r\n});\r\n```\r\n\r\n\r\n## Raw Query\r\n\r\nYou can get the raw query interface from cassandra nodejs-driver using the `execute_query` method.\r\n\r\n```js\r\n\r\nvar query = \"Select * from user where gender=? and age > ? limit ?\";\r\nvar params = ['male', 18, 10];\r\nmodels.instance.Person.execute_query(query, params, function(err, people){\r\n    //people is an array of plain objects\r\n});\r\n\r\n```\r\n\r\n## Batching ORM Operations\r\n\r\nYou can batch any number of save, update and delete operations using the `models.doBatch` function. To use more than one of those functions as a combined batch operation, you need to tell each of the save/update/delete functions, that you want to get the final built query from the orm instead of executing it immediately. You can do that by adding a `return_query` parameter in the options object of the corresponding function and build an array of operations to execute atomically like the following:\r\n\r\n```js\r\nvar queries = [];\r\n\r\nvar event = new models.instance.Event({\r\n    id: 3,\r\n    body: 'hello3'\r\n});\r\nvar save_query = event.save({return_query: true});\r\nqueries.push(save_query);\r\n\r\nvar update_query = models.instance.Event.update(\r\n    {id: 1},\r\n    {body: 'hello1 updated'},\r\n    {return_query: true}\r\n);\r\nqueries.push(update_query);\r\n\r\nvar delete_query = models.instance.Event.delete(\r\n    {id: 2},\r\n    {return_query: true}\r\n);\r\nqueries.push(delete_query);\r\n\r\nmodels.doBatch(queries, function(err){\r\n    if(err) throw err;\r\n});\r\n```\r\n\r\n## Debug Logging Queries\r\n\r\nYou can log the generated queries by the orm if you want. Just set the `DEBUG` environment variable like the following while starting your app:\r\n\r\n```\r\nDEBUG=express-cassandra node app.js\r\n```\r\n\r\n## Raw Batch Query\r\n\r\nYou can get the batch query interface from cassandra nodejs-driver using the `execute_batch` method.\r\n\r\n```js\r\n\r\nvar queries = [\r\n    {\r\n        query: \"...\",\r\n        params: [...]\r\n    },\r\n    {\r\n        query: \"...\",\r\n        params: [...]\r\n    }\r\n];\r\nmodels.instance.Person.execute_batch(queries, function(err){\r\n\r\n});\r\n\r\n```\r\n\r\n## Get the client driver instance\r\n\r\nYou can get the client driver instance from cassandra nodejs-driver using the `get_cql_client` method. This will provide you a cql driver instance with which you can do anything you could possibly do with the datastax nodejs-driver version 3.0.\r\n\r\n```js\r\n\r\nmodels.instance.Person.get_cql_client(function(err, client){\r\n    client.eachRow('Select * from person limit 10', [], { autoPage : true }, function(n, row) {}, function(err, result){});\r\n});\r\n\r\n```\r\n\r\n## Closing connections to cassandra\r\n\r\nYou can close all orm connections to cassandra by using the following function:\r\n\r\n```js\r\nmodels.close(function(err){\r\n    if(err) throw err;\r\n});\r\n```\r\n\r\n## Note\r\n\r\nAll queries except schema definition related queries (i.e. create table etc.) are prepared by default. If you don't want to prepare queries, just set `prepare=false` in the options object.\r\n\r\n```js\r\nmodels.instance.Person.find(query, {prepare: false}, function(err, people){\r\n    //people is an array of plain objects\r\n});\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}